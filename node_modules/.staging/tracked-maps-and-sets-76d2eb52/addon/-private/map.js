import { createStorage, getValue, setValue, } from 'ember-tracked-storage-polyfill';
export class TrackedMap {
    constructor(existing) {
        this.collection = createStorage(null, () => false);
        this.storages = new Map();
        // TypeScript doesn't correctly resolve the overloads for calling the `Map`
        // constructor for the no-value constructor. This resolves that.
        this.vals = existing ? new Map(existing) : new Map();
    }
    readStorageFor(key) {
        const { storages } = this;
        let storage = storages.get(key);
        if (storage === undefined) {
            storage = createStorage(null, () => false);
            storages.set(key, storage);
        }
        getValue(storage);
    }
    dirtyStorageFor(key) {
        const storage = this.storages.get(key);
        if (storage) {
            setValue(storage, null);
        }
    }
    // **** KEY GETTERS ****
    get(key) {
        // entangle the storage for the key
        this.readStorageFor(key);
        return this.vals.get(key);
    }
    has(key) {
        this.readStorageFor(key);
        return this.vals.has(key);
    }
    // **** ALL GETTERS ****
    entries() {
        getValue(this.collection);
        return this.vals.entries();
    }
    keys() {
        getValue(this.collection);
        return this.vals.keys();
    }
    values() {
        getValue(this.collection);
        return this.vals.values();
    }
    forEach(fn) {
        getValue(this.collection);
        this.vals.forEach(fn);
    }
    get size() {
        getValue(this.collection);
        return this.vals.size;
    }
    [Symbol.iterator]() {
        getValue(this.collection);
        return this.vals[Symbol.iterator]();
    }
    get [Symbol.toStringTag]() {
        return this.vals[Symbol.toStringTag];
    }
    // **** KEY SETTERS ****
    set(key, value) {
        this.dirtyStorageFor(key);
        setValue(this.collection, null);
        this.vals.set(key, value);
        return this;
    }
    delete(key) {
        this.dirtyStorageFor(key);
        setValue(this.collection, null);
        return this.vals.delete(key);
    }
    // **** ALL SETTERS ****
    clear() {
        this.storages.forEach((s) => setValue(s, null));
        setValue(this.collection, null);
        this.vals.clear();
    }
}
// So instanceof works
Object.setPrototypeOf(TrackedMap.prototype, Map.prototype);
export class TrackedWeakMap {
    constructor(existing) {
        this.storages = new WeakMap();
        // TypeScript doesn't correctly resolve the overloads for calling the `Map`
        // constructor for the no-value constructor. This resolves that.
        this.vals = existing ? new WeakMap(existing) : new WeakMap();
    }
    readStorageFor(key) {
        const { storages } = this;
        let storage = storages.get(key);
        if (storage === undefined) {
            storage = createStorage(null, () => false);
            storages.set(key, storage);
        }
        getValue(storage);
    }
    dirtyStorageFor(key) {
        const storage = this.storages.get(key);
        if (storage) {
            setValue(storage, null);
        }
    }
    get(key) {
        this.readStorageFor(key);
        return this.vals.get(key);
    }
    has(key) {
        this.readStorageFor(key);
        return this.vals.has(key);
    }
    set(key, value) {
        this.dirtyStorageFor(key);
        this.vals.set(key, value);
        return this;
    }
    delete(key) {
        this.dirtyStorageFor(key);
        return this.vals.delete(key);
    }
    get [Symbol.toStringTag]() {
        return this.vals[Symbol.toStringTag];
    }
}
// So instanceof works
Object.setPrototypeOf(TrackedWeakMap.prototype, WeakMap.prototype);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjLy1wcml2YXRlL21hcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsYUFBYSxFQUNiLFFBQVEsRUFDUixRQUFRLEdBQ1QsTUFBTSxnQ0FBZ0MsQ0FBQztBQUV4QyxNQUFNLE9BQU8sVUFBVTtJQThCckIsWUFDRSxRQUlhO1FBbENQLGVBQVUsR0FBRyxhQUFhLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTlDLGFBQVEsR0FBaUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQWtDekQsMkVBQTJFO1FBQzNFLGdFQUFnRTtRQUNoRSxJQUFJLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDdkQsQ0FBQztJQWpDTyxjQUFjLENBQUMsR0FBTTtRQUMzQixNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBQzFCLElBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFaEMsSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO1lBQ3pCLE9BQU8sR0FBRyxhQUFhLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzNDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQzVCO1FBRUQsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFFTyxlQUFlLENBQUMsR0FBTTtRQUM1QixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV2QyxJQUFJLE9BQU8sRUFBRTtZQUNYLFFBQVEsQ0FBQyxPQUFPLEVBQUUs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QUFjLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFekIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsR0FBRyxDQUFDLEdBQU0sRUFBRSxLQUFRO1FBQ2xCLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTFCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELE1BQU0sQ0FBQyxHQUFNO1FBQ1gsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUUxQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQztRQUN0QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Q0FDRjtBQUVELHNCQUFzQjtBQUN0QixNQUFNLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgVHJhY2tlZFN0b3JhZ2UsXG4gIGNyZWF0ZVN0b3JhZ2UsXG4gIGdldFZhbHVlLFxuICBzZXRWYWx1ZSxcbn0gZnJvbSAnZW1iZXItdHJhY2tlZC1zdG9yYWdlLXBvbHlmaWxsJztcblxuZXhwb3J0IGNsYXNzIFRyYWNrZWRNYXA8SyA9IHVua25vd24sIFYgPSB1bmtub3duPiBpbXBsZW1lbnRzIE1hcDxLLCBWPiB7XG4gIHByaXZhdGUgY29sbGVjdGlvbiA9IGNyZWF0ZVN0b3JhZ2UobnVsbCwgKCkgPT4gZmFsc2UpO1xuXG4gIHByaXZhdGUgc3RvcmFnZXM6IE1hcDxLLCBUcmFja2VkU3RvcmFnZTxudWxsPj4gPSBuZXcgTWFwKCk7XG5cbiAgcHJpdmF0ZSB2YWxzOiBNYXA8SywgVj47XG5cbiAgcHJpdmF0ZSByZWFkU3RvcmFnZUZvcihrZXk6IEspOiB2b2lkIHtcbiAgICBjb25zdCB7IHN0b3JhZ2VzIH0gPSB0aGlzO1xuICAgIGxldCBzdG9yYWdlID0gc3RvcmFnZXMuZ2V0KGtleSk7XG5cbiAgICBpZiAoc3RvcmFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdG9yYWdlID0gY3JlYXRlU3RvcmFnZShudWxsLCAoKSA9PiBmYWxzZSk7XG4gICAgICBzdG9yYWdlcy5zZXQoa2V5LCBzdG9yYWdlKTtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZShzdG9yYWdlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGlydHlTdG9yYWdlRm9yKGtleTogSyk6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLnN0b3JhZ2VzLmdldChrZXkpO1xuXG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgIHNldFZhbHVlKHN0b3JhZ2UsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCk7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXM6IHJlYWRvbmx5IChyZWFkb25seSBbSywgVl0pW10gfCBudWxsKTtcbiAgY29uc3RydWN0b3IoaXRlcmFibGU6IEl0ZXJhYmxlPHJlYWRvbmx5IFtLLCBWXT4pO1xuICBjb25zdHJ1Y3RvcihcbiAgICBleGlzdGluZz86XG4gICAgICB8IHJlYWRvbmx5IChyZWFkb25seSBbSywgVl0pW11cbiAgICAgIHwgSXRlcmFibGU8cmVhZG9ubHkgW0ssIFZdPlxuICAgICAgfCBudWxsXG4gICAgICB8IHVuZGVmaW5lZFxuICApIHtcbiAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgY29ycmVjdGx5IHJlc29sdmUgdGhlIG92ZXJsb2FkcyBmb3IgY2FsbGluZyB0aGUgYE1hcGBcbiAgICAvLyBjb25zdHJ1Y3RvciBmb3IgdGhlIG5vLXZhbHVlIGNvbnN0cnVjdG9yLiBUaGlzIHJlc29sdmVzIHRoYXQuXG4gICAgdGhpcy52YWxzID0gZXhpc3RpbmcgPyBuZXcgTWFwKGV4aXN0aW5nKSA6IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8vICoqKiogS0VZIEdFVFRFUlMgKioqKlxuICBnZXQoa2V5OiBLKTogViB8IHVuZGVmaW5lZCB7XG4gICAgLy8gZW50YW5nbGUgdGhlIHN0b3JhZ2UgZm9yIHRoZSBrZXlcbiAgICB0aGlzLnJlYWRTdG9yYWdlRm9yKGtleSk7XG5cbiAgICByZXR1cm4gdGhpcy52YWxzLmdldChrZXkpO1xuICB9XG5cbiAgaGFzKGtleTogSyk6IGJvb2xlYW4ge1xuICAgIHRoaXMucmVhZFN0b3JhZ2VGb3Ioa2V5KTtcblxuICAgIHJldHVybiB0aGlzLnZhbHMuaGFzKGtleSk7XG4gIH1cblxuICAvLyAqKioqIEFMTCBHRVRURVJTICoqKipcbiAgZW50cmllcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFtLLCBWXT4ge1xuICAgIGdldFZhbHVlKHRoaXMuY29sbGVjdGlvbik7XG5cbiAgICByZXR1cm4gdGhpcy52YWxzLmVudHJpZXMoKTtcbiAgfVxuXG4gIGtleXMoKTogSXRlcmFibGVJdGVyYXRvcjxLPiB7XG4gICAgZ2V0VmFsdWUodGhpcy5jb2xsZWN0aW9uKTtcblxuICAgIHJldHVybiB0aGlzLnZhbHMua2V5cygpO1xuICB9XG5cbiAgdmFsdWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Vj4ge1xuICAgIGdldFZhbHVlKHRoaXMuY29sbGVjdGlvbik7XG5cbiAgICByZXR1cm4gdGhpcy52YWxzLnZhbHVlcygpO1xuICB9XG5cbiAgZm9yRWFjaChmbjogKHZhbHVlOiBWLCBrZXk6IEssIG1hcDogTWFwPEssIFY+KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgZ2V0VmFsdWUodGhpcy5jb2xsZWN0aW9uKTtcblxuICAgIHRoaXMudmFscy5mb3JFYWNoKGZuKTtcbiAgfVxuXG4gIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgZ2V0VmFsdWUodGhpcy5jb2xsZWN0aW9uKTtcblxuICAgIHJldHVybiB0aGlzLnZhbHMuc2l6ZTtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W0ssIFZdPiB7XG4gICAgZ2V0VmFsdWUodGhpcy5jb2xsZWN0aW9uKTtcblxuICAgIHJldHVybiB0aGlzLnZhbHNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudmFsc1tTeW1ib2wudG9TdHJpbmdUYWddO1xuICB9XG5cbiAgLy8gKioqKiBLRVkgU0VUVEVSUyAqKioqXG4gIHNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcyB7XG4gICAgdGhpcy5kaXJ0eVN0b3JhZ2VGb3Ioa2V5KTtcbiAgICBzZXRWYWx1ZSh0aGlzLmNvbGxlY3Rpb24sIG51bGwpO1xuXG4gICAgdGhpcy52YWxzLnNldChrZXksIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGtleTogSyk6IGJvb2xlYW4ge1xuICAgIHRoaXMuZGlydHlTdG9yYWdlRm9yKGtleSk7XG4gICAgc2V0VmFsdWUodGhpcy5jb2xsZWN0aW9uLCBudWxsKTtcblxuICAgIHJldHVybiB0aGlzLnZhbHMuZGVsZXRlKGtleSk7XG4gIH1cblxuICAvLyAqKioqIEFMTCBTRVRURVJTICoqKipcbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5zdG9yYWdlcy5mb3JFYWNoKChzKSA9PiBzZXRWYWx1ZShzLCBudWxsKSk7XG4gICAgc2V0VmFsdWUodGhpcy5jb2xsZWN0aW9uLCBudWxsKTtcblxuICAgIHRoaXMudmFscy5jbGVhcigpO1xuICB9XG59XG5cbi8vIFNvIGluc3RhbmNlb2Ygd29ya3Ncbk9iamVjdC5zZXRQcm90b3R5cGVPZihUcmFja2VkTWFwLnByb3RvdHlwZSwgTWFwLnByb3RvdHlwZSk7XG5cbmV4cG9ydCBjbGFzcyBUcmFja2VkV2Vha01hcDxLIGV4dGVuZHMgb2JqZWN0ID0gb2JqZWN0LCBWID0gdW5rbm93bj5cbiAgaW1wbGVtZW50cyBXZWFrTWFwPEssIFY+XG57XG4gIHByaXZhdGUgc3RvcmFnZXM6IFdlYWtNYXA8SywgVHJhY2tlZFN0b3JhZ2U8bnVsbD4+ID0gbmV3IFdlYWtNYXAoKTtcblxuICBwcml2YXRlIHZhbHM6IFdlYWtNYXA8SywgVj47XG5cbiAgcHJpdmF0ZSByZWFkU3RvcmFnZUZvcihrZXk6IEspOiB2b2lkIHtcbiAgICBjb25zdCB7IHN0b3JhZ2VzIH0gPSB0aGlzO1xuICAgIGxldCBzdG9yYWdlID0gc3RvcmFnZXMuZ2V0KGtleSk7XG5cbiAgICBpZiAoc3RvcmFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdG9yYWdlID0gY3JlYXRlU3RvcmFnZShudWxsLCAoKSA9PiBmYWxzZSk7XG4gICAgICBzdG9yYWdlcy5zZXQoa2V5LCBzdG9yYWdlKTtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZShzdG9yYWdlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGlydHlTdG9yYWdlRm9yKGtleTogSyk6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLnN0b3JhZ2VzLmdldChrZXkpO1xuXG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgIHNldFZhbHVlKHN0b3JhZ2UsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCk7XG4gIGNvbnN0cnVjdG9yKGl0ZXJhYmxlOiBJdGVyYWJsZTxyZWFkb25seSBbSywgVl0+KTtcbiAgY29uc3RydWN0b3IoZW50cmllczogcmVhZG9ubHkgW0ssIFZdW10gfCBudWxsKTtcbiAgY29uc3RydWN0b3IoXG4gICAgZXhpc3Rpbmc/OiByZWFkb25seSBbSywgVl1bXSB8IEl0ZXJhYmxlPHJlYWRvbmx5IFtLLCBWXT4gfCBudWxsIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBjb3JyZWN0bHkgcmVzb2x2ZSB0aGUgb3ZlcmxvYWRzIGZvciBjYWxsaW5nIHRoZSBgTWFwYFxuICAgIC8vIGNvbnN0cnVjdG9yIGZvciB0aGUgbm8tdmFsdWUgY29uc3RydWN0b3IuIFRoaXMgcmVzb2x2ZXMgdGhhdC5cbiAgICB0aGlzLnZhbHMgPSBleGlzdGluZyA/IG5ldyBXZWFrTWFwKGV4aXN0aW5nKSA6IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICBnZXQoa2V5OiBLKTogViB8IHVuZGVmaW5lZCB7XG4gICAgdGhpcy5yZWFkU3RvcmFnZUZvcihrZXkpO1xuXG4gICAgcmV0dXJuIHRoaXMudmFscy5nZXQoa2V5KTtcbiAgfVxuXG4gIGhhcyhrZXk6IEspOiBib29sZWFuIHtcbiAgICB0aGlzLnJlYWRTdG9yYWdlRm9yKGtleSk7XG5cbiAgICByZXR1cm4gdGhpcy52YWxzLmhhcyhrZXkpO1xuICB9XG5cbiAgc2V0KGtleTogSywgdmFsdWU6IFYpOiB0aGlzIHtcbiAgICB0aGlzLmRpcnR5U3RvcmFnZUZvcihrZXkpO1xuXG4gICAgdGhpcy52YWxzLnNldChrZXksIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGtleTogSyk6IGJvb2xlYW4ge1xuICAgIHRoaXMuZGlydHlTdG9yYWdlRm9yKGtleSk7XG5cbiAgICByZXR1cm4gdGhpcy52YWxzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudmFsc1tTeW1ib2wudG9TdHJpbmdUYWddO1xuICB9XG59XG5cbi8vIFNvIGluc3RhbmNlb2Ygd29ya3Ncbk9iamVjdC5zZXRQcm90b3R5cGVPZihUcmFja2VkV2Vha01hcC5wcm90b3R5cGUsIFdlYWtNYXAucHJvdG90eXBlKTtcbiJdfQ==